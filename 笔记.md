# 学习笔记
- 　　本笔记会记录我的学习内容，都是根据自己的理解写的。会比较杂，目前在学习一些关于rtos的内容，就先放到该文件夹下。
- 1.链表  
　　链表一直有听过，但是以前写代码似乎没有机会去用到它，也就没有好好的去看过。其实链表是个非常实用的东西，我在学习链表以后，用它实现了单片机的软件定时器模块，最终的效果是这个定时器模块非常好用，至少在我看来是的。  
　　我们嵌入式软件工程师，天天写程序，也能自称程序员了。那什么是程序，我觉得程序就是数据的存储和数据的处理。数据的存储是数据结构研究的，数据的处理就是算法研究的。链表就是用来存储数据的一种方式。  
　　和链表相对应的是数组，数组大家一定非常熟悉。直接定义类型，然后给一个长度，系统就会分配相应的空间出来。数组的特点是数据是连续的。所以只要给出第一个数据的地址和数据类型，那么数组中任意一个数据都可以找到。数组的使用非常简单，所以应用很普遍。不过既然数组和链表都是存储数据的，而又有链表这种东西的存在，说明数组肯定是有缺点的。数组的缺点有两个，一是数据必须连续。试想一下，如果内存中空间如下：空白512Byte，中间有一段数据，然后又是一个空白的512Byte，以此类推，虽然这么多512Byte加起来是很大的一个空间，但是数组能开辟的空间最大就是512个，因为它要求数据必须连续，内存中找不到更大的连续的空白空间，如果定义数组长度为513，代码编译的时候一定会报错。另一个缺点是数组长度要写死，不能增加，在使用的过程中，发现不够用，那也没办法。（关于数组长度要写死，柔性数组是个例外，我会另外写相关内容介绍）。  
　　链表的出现就是解决数组的这2个弊端，首先，链表从字面意思就能理解。想想你老家栓狗的大铁链子，就是一个一个小铁环组成的，虽然每个铁环都是独立短链，但是他们串在一起，就是一个长链。链表也是这个道理，可以将内存中零散的空间都利用起来，然后利用某种东西串起来，这个东西就是指针，指针在C语言是是个非常强大的东西，灵活的利用指针可以实现很多功能。  
　　最简单的链表形式是单向链表，有2个成员组成，一个当然是数据，因为链表的作用就是存储数据，另一个就是指针，用来指向下一个数据。通过指针将数据串起来。由于链表的特性，可以解决数组的第二个弊端，链表所有的数据可以不连续，那就可以插入数据，只要将前面一个数据的指针指向要插入的数据，再将插入数据的指针指向下一个数据。同样的也可以删除数据。我们把链表里一个成员叫做结点。所以增加减少成员就是插入删除结点。  
　　除了单向链表，还有双向链表，也很简单，结点中多了1个指针，用来指向前一个数据。也就是该结点同时知道它的前后结点。而单向链表只知道它的后一个结点。还有循环链表，就是最后一个结点指向了第一个结点，所有的数据成了一个循环。  
　　最后谈谈链表的缺点。链表会浪费一定的内存空间。因为链表中需要一个指针指向下一个结点。在32位机里，一个指针占用4Byte的空间。假设链表存放的是1Byte的数据，为了这1Byte的数据，需要浪费额外的4Byte空间，而且这还没有考虑数据的对齐问题，实际浪费的空间可能还不止4Byte。所以链表和数组没有绝对的好坏，它们有各自的特点，在使用过程中，选择最合适的就好。  
- 2.队列  
　　队列也是存数据的一种形式，它的特点是数据先入先出，就像队伍排队一样。一般来说，插入数据是插入队列的最后面，取出数据是从队列的最前面取。紧急事件可以根据优先级插队。在队列中会有头和尾用来表示队列的状态。当头和尾不相等，说明队列是有数据的，可以继续取；而头和尾相等时，说明队列是空的，没东西可取了。不过也有可能是整个队列全部存满了。为了避免这种歧义，一般有2种方法处理，1是增加一个变量用来记录实际的数据量，只要数据量不为零，就能知道头尾相等究竟是队列空还是满了；另一种方法是浪费一个空间，当队列只剩下最后一个空间时，就认为队列满了。所以头尾相等即为空，尾+1=头即为满。  
　　队列的概念简单，不过确实很实用。比如最常用的串口收发数据，就可以用队列管理。一般的MCU串口只有1Byte的buf，在接收数据时，收一个处理一个肯定是不合适的，所以会建一个数组作为缓存，收到的数据先往数组里放，然后从数组取数据处理。利用队列的管理方式，收一个数据，尾+1；取一个数据，头+1。通过前面讲的头尾关系，可以很方便的知道数组里数据的情况。发送数据同理。  
　　队列里的数据除了可以是char，int之类的数据以外，也可以是指针。将要执行的任务的函数指针都放到队列里，能方便的管理任务。  
- 3.调度器  
　　调度器通过相关调度算法决定当前要执行的任务。所有调度器有一个共同特性：区分就绪态任务和挂起任务。嵌入式RTOS的核心是调度器和任务切换。调度器的核心是调度算法，而现在的RTOS，任务切换方式都差不多，区别主要在调度器。常见的调度器有合作式调度器，抢占式调度器，时间片调度器。  
　　合作式调度器：合作式调度器会根据用户的设置来执行任务，每个时刻只有一个任务可以执行，任务之间不支持抢占，直到占据CPU的任务执行完。所以该调度器比较简单，且安全可靠。但是实时性不强。  
　　抢占式调度器：所有的任务都有各自的优先级。高优先级的任务只要就绪，就可以获取CPU使用权，同时低优先级的任务挂起。若发生中断，在中断程序中，高优先级的任务就绪，那么退出中断以后，不会退回到发生中断之前的任务函数，而是优先执行高优先级的任务。该调度器实时性好，但是实现起来会比较麻烦。  
　　时间片调度器：调度器给每个任务分配一个时间片，每个任务根据时间片长度执行。即给每个任务定个运行时间长度，时间到了就要切换任务。在任务实时性要求不是非常高的场合可以用。
