该笔记整理自野火的 从0到1教你写uCOS-III，一边练习一边记录。  
- 裸机程序与多任务系统  
　 　裸机系统是我们刚学单片机时，最先接触到的写法。主程序进入main函数，一堆初始化，然后一个while(1)死循环，要执行的事件都放在里面。需要立即响应的事件，用中断处理。  
　 　裸机系统分为轮询系统和前后台系统。轮询系统即所有的事件都是按照顺序一件一件的执行，比如有3件事情要做，大家排队一件一件执行，A没有执行完，B就得等着。事件都是通过查询的方式执行，例如按下一个按键点亮一个LED，那么判断按下按键就是通过查询电平是否改变实现的，如果系统有别的事情要做，按下按键的时候没有运行到相应的代码，那就会漏判。按下按键需要消斗，最初学的写法就是死等个几个毫秒，然后再查询电平是否改变。这几个毫秒会拖累整个系统不能流畅执行，这就是轮询系统的弊端，各个任务之间有干扰，如果一个任务执行的时间很长，必然会拖累别的任务的执行。当然它的优点就是写法简单，代码量小。用在小型的功能中是比较合适的。  
　 　前后台系统本质和轮询系统类似，加入了中断，这样紧急的事情可以立即响应到，比如上面提到的按键，不管之前一个任务耗时多长，只要按键按下，就能立即中断响应，不会漏判。若要执行的任务非常紧急或者时间很短，可以直接在中断中处理。否则建议在中断中置个标志，然后在外部轮询中查询该标志处理事件。因为在中断中停留的时间不宜过久。轮询的部分叫做前台，中断的部分叫做后台，所以该种方式称作前后台系统。前后台分工合作，基本所有的嵌入式开发都能用这种方式实现，可以说是无所不能。很多老工程师做了很多年的嵌入式开发，他们都是用这种方式开发产品的。本人也是用这种方式做了好几年的开发。  
　 　除了裸机程序，还有多任务系统。多任务系统引入了任务的概念。事件的处理是在任务中完成，任务和中断一样，有优先级。每个任务都是一个while(1)的死循环，这样开发者在编程的时候，精力可以更多的花在编写功能上，不用管每个模块是否相互干扰。裸机程序就必须要协调好各个模块，裸机程序的代码一定要跑起来，不能有堵塞。而多任务系统就可以有堵塞，因为每个任务本身就是一个死循环。它通过操作系统这一“外部力量”，让代码在各个死循环中切换。  
-  任务的切换  
　 　在编写裸机系统的时候，会用到全局变量，函数调用等。很多时候，我们并不会去关心这些东西到底是放在那里。但是用RTOS，就必须关心，因为每个任务都是相互独立的，不能干扰。这些东西都是放在栈里面，多任务系统会将栈空间分配城独立的空间，来存放各个任务的信息。多任务系统中，为了保证系统调度任务，每个任务需要额外定义一个任务控制块TCB，TCB里会存放任务的信息，如堆栈，名称等。具体的任务切换是由汇编语言实现的，是操作了硬件的内核。例如STM32F1系列，那就要看CORTEX-M3的内核，操作相应寄存器。原理是产生PendSV异常，然后在异常服务函数里切换上下文。首先将PendSV的优先级设成0xff，即优先级最低，这样就可以保证在异常服务函数里，不会切换上下文。然后触发PendSV异常。只需要往0xE000ED04寄存器的bit28写1，即可触发异常，类似于发生了一次中断。在切换上下文的时候，还需要保存相应任务的寄存器值。有些寄存器是系统自动压栈，我们不用去管。而像R4-R11这些寄存器，我们需要手动去存储他们的值，然后任务恢复的时候，先恢复它们的值，这样可以确保上下文切换时，各个任务的参数不会乱套。
　 　任务的流程是先初始化OSInit，然后注册任务OSTaskCreate，最后启动任务OSStart。我们要写的任务就是写成一个个死循环，然后注册就行了。操作系统会帮我们调度。这部分代码目前正在学习。创建任务的时候，需要传入的参数有OS_TCB *p_tcb,OS_TASK_PTR p_task,void *p_arg,CPU_STK *p_stk_base,CPU_STK_SIZE stk_size,OS_ERR *p_err。p_tcb是任务控制块指针，p_task 是任务函数名，：p_arg是任务形参，用于传递任务参数，p_stk_base 用于指向任务堆栈的起始地址，stk_size 表示任务堆栈的大小，p_err 用于存错误码。
 
关于时间管理
时间管理是通过硬件时钟实现的。在硬件时钟的基础上，实现软件定时器。
定时的管理方式：
1.简单计数 每过一个时钟节拍，所有的任务都计数减1，当计数为0时，执行相应的任务。
2.差分计时 先将计时排序，从小到达，当第一个时间减完以后，后面所有的也减去响应的时间。然后再减第二个时间。比如ABCD任务分别要延时2 5 4 7个时间节拍。那就将时间排成2 4 5 7，分别执行2 2 1 2个时间节拍就行了。因为执行第一个2，则A任务完成，同时C B D任务分别剩下2 3 5。然后再执行第二个2，C任务完成，B D任务还剩下1 3。然后执行完B，最后是D。
3.时间车轮 建一个时间数组，每个数组的长度都是固定的，比如100ms。称为一个时间槽，当运行完一个时间槽，时间达到的任务就执行。当时间槽的值较大，则每个任务的执行时间会有较大误差。
