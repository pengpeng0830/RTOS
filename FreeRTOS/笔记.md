# FreeRTOS学习笔记
- 学习路线整理《Using the FreeRTOS Real Time Kernel》一文而来。重点记录的是原理，而不是如何使用。  
- 任务管理：  
　　FreeRTOS的每个任务都是一段独立的程序。每个程序都是一个死循环。而且死循环不可以用break或return之类的语句退出。任务简单的划分可以分为运行状态和非运行状态。任务有优先级，优先级数值越小表示优先级越低。调度器保证总是在所有可运行的任务中选择具有最高优先级的任务，并使其进入运行态。如果高优先级的任务一直处于运行态。低优先级的任务将得不到运行。相同优先级的任务会有一个时间片，时间片开始就进入运行态。结束进入非运行态。由于该种特性，任务是不可以一直处于运行状态的，除非该任务处于最低的优先级，否则比它低优先级的任务永远没有可能执行。所以任务需要切换到非运行态。举例来说，比如任务一是让一个LED闪烁。而任务二让另一个LED闪烁。如果2个闪烁的方式是最传统的死循环延时方式，若2个任务同等优先级，则2个LED均可以正常闪烁。而任务一的优先级高于任务二，则任务二对应的LED是没有机会闪烁的。类似的等待时间，需要让任务处于堵塞态而不是死循环死等，死等其实也是运行态，应为CPU需要不断的计数然后判断数据是否达到设定的时间，虽然这么做仅仅是为了耗时间，但CPU确实是在运行的。如果用堵塞态，调度器就会去执行低优先级的事件。若没有低优先级的事情可做。将进入空闲状态。  　
　　FreeRTOS是可以改变任务优先级的，修改优先级以后，调度器是会去执行更高优先级的任务。创建的任务可以删除。  
　　调度算法：一：优先级抢占式调度。特点有 1.每个任务都赋予了一个优先级。2.每个任务都可以存在于一个或多个状态。3.在任何时候都只有一个任务可以处于运行状态。4.调度器总是在所有处于就绪态的任务中选择具有最高优先级的任务来执行。二：选择任务优先级，常用的一种方式是单调速率调度。根据任务周期性执行的速率来分配一个唯一的优先级。具有最高周期执行频率的任务赋予高最优先级；具有最低周期执行频率的任务赋予最低优先级。三：协作式调度。任务永远不会被抢占。  
- 队列管理：  
　　FreeRTOS的每个任务都是一段独立的程序。任务之间大多都会有交互。可能某个任务要在另一个任务发生之后才能开始。任务之间的通信就是通过队列实现的。我在别的地方有专门讲过这个队列。FreeRTOS的队列的特性如下：1.数据存储，这是最本质的特性，数组就是用来存东西的。2.可被多任务存取，由于队列只是一个存储的工具，当然不同的任务都可以对同一个队列操作。一般来说，一个队列被多个任务写入比较常见，被多个任务读取就不多见了。3.读/写队列时堵塞，队列有3个状态。满/空/非空非满。当队列满的时候，就不能写入；空的时候不能读取。所以FreeRTOS有一个堵塞超时机制。当队列不能操作的时候，就切换到堵塞态，给别的任务去执行。当队列可以操作的时候再来操作，当然这个等待不能时间太长。所以最长时间就是堵塞时间。  
　　在创建队列时，需要制定单元个数，和每个单元对应的长度。比如建一个数组，有10个单元，每个单元存放的是字符型。那就是10个byte。而每个单元存放的都是指针，那就是40byte。系统会在堆中申请相应大小的内存，如果空间不够则会申请失败。FreeRTOS提供了专门的API函数来读/写队列。也有查询队列中有效数据个数的API。前面讲到队列的特性，可被多任务存取，那该如何区分不同数据的来源。可以使用队列传递复合数据类型，其实就是结构体。队列里存放结构体类型，结构体成员除了数据，还有说明这个数据的来源。这样就能区分不同数据的来源。  
　　队列除了可以直接存放数据以外，当然也可以存放指针，这样存放的东西就非常灵活，功能更加强大。但是使用起来一定要小心。1.指针指向的空间所有权要明确，就是保证不会有任意两个任务同时修改共享内存中的数据。2.指针指向的内存要有效，因为是指针，所以实体要永远存在，实体不能存放在栈里面，释放以后队列里的指针就没有意义了。  
- 中断管理  
　　延迟中断处理：使用二值信号量同步。当一个任务需要延时处理时候，任务先进入堵塞状态，等发生中断时，任务会解除堵塞，这样可以实现任务和中断的同步。所谓同步，可以理解为一起执行。进入堵塞状态，术语可以叫获取信号量，解除堵塞状态叫给出信号量。二值信号量的本质就是一个队列，只是这个队列只有一个空间。所以只存在空/满两种状态。具体实现过程为：延时处理任务调用API时，若队列为空会进入堵塞态。当进入中断会放一个信号量到队列，这时延时任务就可以获取到这个信号量，切出堵塞态，实现一个延迟中断处理功能。在中断中的API一般是给出信号量的，它有一个参数需要注意，就是当给出信号以后，获取该信号的任务优先级高于当前任务（就是被中断的任务），正常来说结束中断以后，应该回到进中断之前的函数继续执行。但是由于更高优先级的任务已经相应了，系统就必须先执行更高优先级的任务，再来执行这个被中断的任务。这时候API会修改这个参数，告知确实需要先执行更高优先级任务，需要在中断退出之前进行上下文切换。  
　　计数信号量：计数信号量的原理和二值信号量一样。二值信号量就是一种计数信号量的特殊形式，计数信号量具有多个数据单元。计数信号量有2种典型用法：分别是事件计数和资源管理。事件计数就是把成员存放信号量，原理和二值信号量一样。资源管理则是把成员存放可用资源数目。  
- 资源管理  
　　多任务系统会有一种风险，即一个任务在使用某资源时，如果访问到一半就切出，然后有别的任务来继续执行，那就乱套了。比如打印字符的时候，打印到一半有别的打印任务插入，那最后打印的东西就乱了，不是任何一个任务想要的东西。其实这在之前写单片机任务也遇到过。某些函数写出来，可以被任意的调用，不用管理。而有些函数就没那么自由，不可以随便用。比如函数中有static这种静态变量记状态。  
　　在RTOS中，这种概念叫互斥，这样做的目的是要确保任务从开始访问资源就具有排它性。不过FreeRTOS有说明，最好的互斥方法还是自己写程序的时候注意，尽量不要共享资源。系统API函数提供了临界区与挂起调度器两种方式。临界区是提供互斥功能的一种非常原始的实现方法，仅仅是简单地把中断全部关掉，缺点是只能用很短的时间，否则会影响中断响应时间。而挂起调度器可以保护一段代码区间不被其它任务打断，但系统的中断依然是使能的，缺点是唤醒调度器要一个相对较长的事件。  
　　互斥量：互斥量是一种特殊的二值信号量，用于控制在两个或多个任务间访问共享资源。在互斥的场合下，一个任务想要访问资源，必须获得（take）到相关的资源，如果take成功，访问完资源，必须立刻归还（give）该资源，不然别的任务就没法take到该资源。所以互斥信号量用完之后必须归还，之前提到过二值信号量的另一种形式，同步信号量，不同点是同步信号量用完就丢失，不用归还。举例说明：若有AB两个任务，都是打印字符串。A的优先级低于B。A执行以后，A要打印字符串，打印之前先take信号量，take成功以后打印，打印完give该信号量。然后B按照这个方法再次打印。由于B的优先级高于A，在A打印的过程中是B是可以打断A的流程，但是由于信号量已经被A take到，B无法take到，B只能进入堵塞态，A继续执行。所以A的打印不会由于高优先级的B插入而打断。不过这就带来了一个问题，优先级反转。就是高优先级的任务反而要等低优先级的任务执行完。如果将优先级反转的问题放大。举例说明，AB任务还是不变。再加入C任务，优先级介于AB之间。那么前面提到，低优先级的A先执行，高优先级的B由于要等待信号量，需要等A执行完。若此时C任务也执行，并且不需要take那个信号量。那C是可以抢占A的执行权。导致最终的优先级变成了C最高。如果C一直执行，最高优先级的B是永远无法执行到的。为了降低优先级反转的问题，可以采用优先级继承的方式，但是这种方式并不能完全解决该问题。优先级继承就是将互斥量持有者的优先级提升至所有等待此互斥量的任务所具有的最高优先级。等give了信号量。再将优先级还原。之前的例子ABC，可以暂时将A的优先级提高到和B相同。所以A的优先级就会暂时高于C，那么A执行完，再give信号量，同时还原A的优先级。此时B任务就可以正常执行了，更低优先级的C就只能等B执行完。不过这种方式比较麻烦，所以FreeRTOS提供的优先级反转策略也比较简单。建议尽量避免使用。  
　　使用互斥量有个潜在的问题，其实上面已经提到，一个任务必须take到信号才能执行。假如有2个任务，都需要take2个信号才能执行。如果A任务在take到第一个信号量以后，被更高优先级的B抢占任务，Btake到另一个信号量。那2个任务各take到一个信号量。都是永远无法执行起来，自然也就无法give信号量。这种情况叫做死锁。在设计的时候要规避这种风险。  
　　守护任务：守护任务是另一种实现互斥的方式，同时不必担心优先级反转和死锁问题。基本实现原理是，对于要访问的资源，守护任务是访问的唯一直接途径，其它任务想要访问，只能间接的通过守护任务访问。还是拿打印的任务做例子，AB任务需要打印不同的内容，则需要创建AB2个任务，同时需要额外建立一个守护任务，打印的操作是在守护任务里执行。由于打印的任务只有在守护任务里有，所以守护任务中不需要考虑互斥问题。AB任务可以通过队列管理来存储打印字符，将要打印的字符串的地址放到队列中，就算AB之间有优先级的区分，可以随意的切换任务，但由于打印都是需要守护任务这唯一的途径来完成，所以打印出的字符串一定是完整的。一般来说，守护任务的优先级会低于其他任务。当然有时候为了更快的处理消息，也可以将守护任务的优先级设的很高，不过这样会使得其它任务执行被推迟。  
- 内存管理  
　　在使用链表或者队列时，需要动态分配内存。C语言标准库提供了malloc和free两个函数。不过对于嵌入式系统这种小型的系统，可能不是最合适的。所以FreeRTOS提供了3个头文件，供用户选择（最新的版本有5个头文件），用pvPortMalloc申请内存，vPortFree释放内存。简单介绍一下3个头文件的区别。Heap_1.c，只提供了最基本的pvPortMalloc函数，不提供vPortFree。由于不能释放内存，改方式只适用于创建的任务，队列信号量等不能释放的场合。Heap_2.c，是支持vPortFree释放内存的，且采用了最佳匹配算法来分配内存，它会优先申请最接近申请内存大小的空间。比如说堆空间中有3个空闲块，分别是5,25,100字节。如果申请了20个字节的空间，那么会占用25字节的内存块，而不会用100字节的。可最大限度避免内存碎片的问题。Heap_3.c，就是直接用的标准库函数malloc和free，但是会通过暂时挂起调度器的方式保证线程的安全性。
 
